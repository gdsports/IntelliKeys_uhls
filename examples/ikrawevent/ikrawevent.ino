/*
 * Demonstrate the use of the USB Host Library for SAMD IntelliKeys (IK) USB
 * host driver. Send raw IK events out a Serial port
 */

#include <IntelliKeys.h>

// On Arduino Zero debug on and send JSON to debug port
#if defined(ARDUINO_SAMD_ZERO)
#define DBSerial  if(1)Serial
#define IKSerial  Serial1
#else
// All other boards including Trinket M0, debug off and send JSON to Serial1
#define DBSerial  if(0)Serial
#define IKSerial  Serial1
#endif

USBHost myusb;
IntelliKeys ikey1(&myusb);

char mySN[IK_EEPROM_SN_SIZE+1]; //+1 NUL

#ifdef ADAFRUIT_TRINKET_M0
// setup Dotstar LED on Trinket M0
#include <Adafruit_DotStar.h>
#define DATAPIN    7
#define CLOCKPIN   8
Adafruit_DotStar strip = Adafruit_DotStar(1, DATAPIN, CLOCKPIN, DOTSTAR_BRG);
#endif

// Raw undecoded events from the IK. Just send them as-is.
// The byte following the length is the event type.
void IK_raw_event(const uint8_t *rxevent, size_t len)
{
  if ((*rxevent == IK_EVENT_MEMBRANE_PRESS) || (*rxevent == IK_EVENT_MEMBRANE_RELEASE)) {
    DBSerial.print("ev="); DBSerial.println(*rxevent);
  }
  switch (*rxevent) {
    case IK_EVENT_MEMBRANE_PRESS:
    case IK_EVENT_MEMBRANE_RELEASE:
    case IK_EVENT_SWITCH:
    case IK_EVENT_CORRECT_MEMBRANE:
    case IK_EVENT_CORRECT_SWITCH:
    case IK_EVENT_VERSION:
      IKSerial.write(0xFF);
      IKSerial.write(3);
      IKSerial.write(rxevent, 3);
      break;

    case IK_EVENT_ONOFFSWITCH:
      IKSerial.write(0xFF);
      IKSerial.write(2);
      IKSerial.write(rxevent, 2);
      break;

    case IK_EVENT_CORRECT_DONE:
      IKSerial.write(0xFF);
      IKSerial.write(1);
      IKSerial.write(rxevent, 1);
      break;

    case IK_EVENT_SENSOR_CHANGE:    // See IK_sensor
    case IK_EVENT_EEPROM_READBYTE:  // See IK_get_SN
      break;

    default:
      USBTRACE2("Unknown event code=", *rxevent);
      break;
  }
}

void IK_sensor(int sensor_number, int sensor_value)
{
  uint8_t evt[5] = {0xFF, 3, IK_EVENT_SENSOR_CHANGE,
    (uint8_t)sensor_number, (uint8_t)sensor_value};
  IKSerial.write(evt, sizeof(evt));
}

// The following events are generated by the driver, not the IK.
void IK_connect(void)
{
  uint8_t buf[3] = {0xFF, 1, IK_EVENT_CONNECT};
  IKSerial.write(buf, sizeof(buf));
}

void IK_disconnect(void)
{
  uint8_t buf[3] = {0xFF, 1, IK_EVENT_DISCONNECT};
  IKSerial.write(buf, sizeof(buf));
  memset(mySN, 0, sizeof(mySN));
}

void IK_get_SN(uint8_t SN[IK_EEPROM_SN_SIZE])
{
  memcpy(mySN, SN, IK_EEPROM_SN_SIZE);
  mySN[IK_EEPROM_SN_SIZE] = '\0';
}

void IK_put_SN()
{
  uint8_t buf[3] = {0xFF, IK_EEPROM_SN_SIZE+1, IK_EVENT_SERNUM};
  IKSerial.write(buf, sizeof(buf));
  IKSerial.write(mySN, IK_EEPROM_SN_SIZE);
}

void readCommand()
{
  static uint8_t command[16];
  static size_t cmdLen;
  static uint8_t *p;
  static uint8_t cmdState;

  if (!ikey1.isReady()) return;

  while (IKSerial.available() > 0) {
    size_t bytesIn;
    switch (cmdState) {
      case 0: // Scan for 0xFF
        if (IKSerial.read() == 0xFF) {
          cmdState = 1;
        }
        break;
      case 1: // Get cmdLen value
        cmdLen = IKSerial.read();
        if (cmdLen > sizeof(command)) cmdLen = sizeof(command);
        p = command;
        cmdState = 2;
        break;
      case 2: // Get cmdLen bytes
        bytesIn = IKSerial.readBytes(p, cmdLen - (p - command));
        if (bytesIn > 0) {
          p += bytesIn;
          if (cmdLen == (p - command)) {
            cmdState = 0;
            // Have a complete command
            execCommand(command, cmdLen);
          }
        }
        break;
      default:
        DBSerial.print("Invalid cmdState ");
        DBSerial.println(cmdState);
        break;
    }
  }
}

void execCommand(const uint8_t *command, size_t len)
{
  switch (command[0]) {
    case IK_CMD_GET_VERSION:
      ikey1.get_version();
      break;
    case IK_CMD_LED:
      ikey1.setLED(command[1], command[2]);
      break;
    case IK_CMD_TONE:
      ikey1.sound(command[1], command[3], command[2]);
      break;
    case IK_CMD_ONOFFSWITCH:
      ikey1.get_onoff();
      break;
    case IK_CMD_CORRECT:
      ikey1.get_correct();
      break;
    case IK_CMD_RESET_DEVICE:
      ikey1.reset();
      break;
    case IK_CMD_ALL_SENSORS:
      ikey1.get_all_sensors();
      break;
    case IK_CMD_GET_SN:
      IK_put_SN();
      break;
    case IK_CMD_EEPROM_READBYTE:
    case IK_CMD_SCAN:
    case IK_CMD_GET_EVENT:
    case IK_CMD_INIT:
    case IK_CMD_EEPROM_READ:
    case IK_CMD_EEPROM_WRITE:
    case IK_CMD_START_AUTO:
    case IK_CMD_STOP_AUTO:
    case IK_CMD_ALL_LEDS:
    case IK_CMD_START_OUTPUT:
    case IK_CMD_STOP_OUTPUT:
      break;
    default:
      break;
  }
}

void setup() {
  // Turn off built-in RED LED
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW);
#ifdef ADAFRUIT_TRINKET_M0
  // Turn off built-in Dotstar RGB LED
  strip.begin();
  strip.clear();
  strip.show();
#endif
  DBSerial.begin(115200);
  DBSerial.println("IntelliKeys USB Test");
  // If there are concerns about IKSerial transmission being too slow, boost
  // the UART speed. 4*115200 or 8*115200 works on the SAMD21. Make sure to
  // match the UART speed on the other side.
  IKSerial.begin(115200);
  myusb.Init();

  ikey1.onConnect(IK_connect);
  ikey1.onDisconnect(IK_disconnect);
  ikey1.onSensor(IK_sensor);
  ikey1.onSerialNum(IK_get_SN);
  ikey1.onRawEvent(IK_raw_event);
  memset(mySN, 0, sizeof(mySN));
}

void loop() {
  myusb.Task();
  ikey1.Task();
  readCommand();
}
